# 생성자

생성자는 인스턴스가 생성될 때 허출되는 '**인스턴스 초기화 메서드**' 이다. 인스턴스의 초기화 작업이나 생성 시 실행되어야 할 작업을 위해서 사용된다.

    인스턴스 초기화: 인스턴스 변수의 초기화

생성자 역시 메서드와 같이 클래스 내에 선언된다. 구조도 메서드와 유사하지만 **리턴값이 없다는 것이 차이**이다. 하지만 키워드 `void`를 사용하지는 않는다.

### 생성자의 조건

    1. 생성자의 이름은 클래스의 이름과 같아야 한다.
    2. 생성자는 리턴 값이 없다.

생성자의 정의는 다음과 같다. 생성자도 메서드이기에 `오버로딩이 가능하다`는 것에 주의하자. (여러개의 생성자가 존재할 수 있다.)

```java
클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 수행될 코드
    // 주로 인스턴스 변수의 초기화 코드를 적음
}

class Card() {
    Card() {                  // 매개변수가 없는 생성자
        // ...
    }

    Card(String k, int num) { // 매개변수가 있는 생성자
        // ...
    }
}
```

    연산자 new가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하는 것이 아님에 주의한다.

생성자는 단순히 인스턴스변수들을 초기화하는데에 사용되는 조금 특별한 메서드일 뿐, 생성에 관연하지 않는다.

위 `Card`클래스의 인스턴스를 생성하는 코드를 예로 들어, 수행되는 과정을 단계별로 나누어 보면 아래와 같다.

`Card c = new Card();`

    1. 연산자 new에 의해서 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
    2. 생성자 Card()가 호출되어 수행된다.
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

즉, 인스턴스를 생성하기 위해 사용했던 `클래스이름()`이 바로 생성자이다. 인스턴스를 생성할 때에는 반드시 클래스 내의 생성자 중 하나를 선택하여 지정해주어야 한다.

### 기본 생성자

 컴파일 시 소스파일의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일한다.

 ```java
 클래스이름() {}
 Card() {}
 ```
 특별히 인스턴스 초기화 작업이 요구되어지지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용하는 것도 좋다.

> 클래스의 `접근 제어자(Access Modifier)`가 `public`인 경우에는 기본 생성자로 `public 클래스이름() {}`이 추가된다.

```java
class Data1 {
    int value;
}

class Data2 {
    int value;

    Data2(int x) { // 매개변수가 있는 생성자
        value = x;
    }
}

class ConstructorTest {
    public static void main(String[] args) {
        Data1 d1 = new Data1();
        Data2 d2 = new Data2(); // 컴파일 에러
    }
}
```

`Data2`에서 `Data2()`라는 생성자를 찾을 수 없기에 컴파일 에러가 발생한다. 따라서 `Data2`의 인스턴스를 생성할 때 `Data2(int x)`를 사용하던가, 클래스 `Data2`에 생성자 `Data2()`를 추가로 정의해주면 된다.

> 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

### 매개변수가 있는 생성자

인스턴스를 생성할 때, 매개변수가 없다면 인스턴스 생성 이후에 인스턴스변수들을 따로 초기화해주어야 하나, 매개변수가 있는 생성자를 사용한다면 인스턴스 생성 동시에 원하는 값으로 초기화를 해 줄 수 있다. 따라서 매개변수를 가진 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만든다.

```java
Car c = new Car();
c.color = "white";
c.gearType = "auto";
c.door = 4;
-->
Car c = new Car("white", "auto", 4);
```

### 생성자에서 다른 생성자 호출하기

같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다. 단, 다음의 두 조건이 만족되어야 한다.

    - 생성자의 이름으로 클래스이름 대신 this를 사용한다.
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 할 것이므로, 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.

```java
Car() {
    color = "white";
    gearType = "auto";
    door = 4;
}
-->
Car() {
    this("white", "auto", 4);
}
```
인스턴스 변수의 초기화를 간략히 진행할 수 있다.

### 생성자를 이용한 인스턴스의 복사

현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자를 이용할 수 있다. 두 인스턴스가 같은 상태를 갖는다는 것은 두 인스턴스의 모든 인스턴스 변수(상태)가 동일한 값을 갖고 있다는 것을 말한다.

하나의 클래스로부터 생성된 모든 인스턴스의 메서드와 클래스변수는 서로 동일하기 때문에 인스턴스간의 차이는, 인스턴스마다 각기 다른 값을 가질 수 있는 인스턴스변수 뿐이다.

```java
Car(car c) {
    color = c.color;
    gearType = c.gearType;
    door = c.door;
}
```
위 코드는 `Car` 클래스의 참조변수를 매개변수로 선언한 생성자이다. 매개변수로 넘겨진 참조변수가 가리키는 `Car`인스턴스의 인스턴스변수인 `color`, `gearType`, `door`의 값을 인스턴스 자신으로 복사하는 것이다.

> 어떤 인스턴스의 상태를 전혀 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있다.

생성자 `Car(Car c)`는 아래와 같이 다른 생성자인 `Car(String color, String gearType, int door)`을 이용하여 호출하는 것이 인스턴스의 변수값의 변경이 다른 인스턴스에도 영향을 주도록 설계할 수 있다.

```java
Car(Car c ) {
    // Car(String color, String gearType, int door)
    this(c.color, c.gearType, c.door);
}
```

    인스턴스를 생성할 때에는 다음의 2가지 사항을 결정해야 한다.
    1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
    2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

