# 형변환

## 형변환 (캐스팅, casting)

변수 또는 상수의 타입을 다른 타입으로 변환하는 것

### 형변환 방법

#### 명시적 형변환

변수나 리터럴 앞에 변환하고자 하는 타입을 붙여주면 됨

```java
// (타입)피연산자
double d = 85.4;
int score = (int)d; // double형 변수 d를 int로 변환

// 단계별 연산과정
int score = (int)d;
--> int score = (int)85.4;
--> int score = 85;
```

기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다.

또한 기본형과 참조형 사이에서 형변환은 불가능하다.

#### 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙이나 경우에 따라 형변환을 생략할 수 있다. 이때 컴파일러가 생략된 형변환을 자동적으로 추가한다.

```java
float f = 1234; // 형변환의 생략. float f =(float)1234; 와 동일
```

그러나 변수가 지정할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생한다.

```java
byte b = 1000; // 에러. byte의 범위(-128~127)를 넘는 값을 저장
```

명시적 형변환이 이루어지면 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

```java
char ch = (char)1000; // 에러가 발생하지 않는다
```

또 계산식에서 자주 형변환이 생략되는데, 서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 후에 연산이 시행되어야 하므로 연산과정에서 형변환이 자동적으로 이루어진다.

```java
int i = 3;
double d = 1.0 + i; // double d = 1.0 + (double)i; 에서 형변환이 생략됨
```

서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행한다. 값손실의 위험이 더 적어져 올바른 결과를 얻을 확률이 높기 때문이다.

```java
double d = 1.0 + i;
--> double d = 1.0 + (double)i;
--> double d = 1.0 + (double)3;
--> double d = 1.0 + 3.0;
--> double d = 4.0;
```

이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다. (후술)

#### 자동 형변환의 규칙

> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.

표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환한다.

```java
1 byte   2 byte    4 byte   8 byte   4 byte     8 byte
 byte --> short -->  int --> long --> float --> double
          char  -----↑
```
화살표 방향대로의 형변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되나 그 외의 경우에는 형변환 연산자를 명시해주어야 한다.

실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정수형보다 훨씬 더 큰 표현 범위를 갖기 때문에 ```float```과 ```double```이 같은 크기인 ```int```와 ```long```보다 오른쪽에 위치한다.

> 1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
> 2. 기본형과 참조형은 서로 형변환할 수 없다.
> 3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
     값의 범휘가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
