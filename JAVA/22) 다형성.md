# 다형성(polymorphism)

'여러 형태를 가질 수 있는 능력'으로 상속과 밀접한 관련이 있다. 자바는 한 타입의 참조변수로 여러 타입의 객체 변수를 참조할 수 있도록 함으로써 다형성을 구현하였다.

즉, 부모클래스 타입의 참조변수로 자식클래스의 인스턴스를 참조할 수 있도록 하였다. 

```java
 class Bird {
    boolean wing; // 날개
    void fly() {
        System.out.println("파닥파닥");
    }
 }

 class Duck extends Bird {
    void quack() {
        System.out.println("꽥꽥");
    }
 }
 ```

 `Bird`와 `Duck`은 서로 상속관계에 있으며, 이 두 클래스의 인스턴스를 생성하고 사용하려면 아래와 같이 진행한다.

 ```java
 Bird b = new Bird();
 Duck d = new Duck();
 ```

 이는 인스턴스의 타입과 일치하는 타입의 참조변수를 사용한 것이다. 하지만 두 클래스가 위와 같이 상속관계에 있는 경우, 부모 클래스 타입의 참조변수로 자식 클래스의 인스턴스를 참조하게 하는 것도 가능하다.

 ```java
 Bird b = new Duck();
 ```

#

 그럼 이제 두 경우의 차이를 알아보자.

1)  ```java 
    Duck d = new Duck();
    ```
    인스턴스는 `Duck` 형이고, `Bird`와 `Duck`의 모든 인스턴스 멤버들을 사용할 수 있다.

2) ```java
   Bird b = new Duck();
   ```
   인스턴스는 `Duck`형으로 동일하지만, `Duck`의 인스턴스 중에서 `Bird`의 멤버(상속받은 멤버 포함)만 사용할 수 있다. 따라서 참조변수 `b`로 `Bird`클래스에 정의되지 않은 멤버 호출인 `b.quack()`등은 사용이 불가능하다.

#

그렇다면 아래와 같이 자식클래스의 참조변수로 부모타입의 인스턴스를 참조할 수 있을까?

```java
Duck d = new Bird();
```

불가능하다(컴파일 에러가 발생한다). 이는 실제 인스턴스인 `Bird`의 멤버 개수보다 참조변수 `d`가 사용할 수 있는 멤버의 개수가 많기 때문이다.

> 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 많아야 한다.

클래스는 상속을 통해 확장될 수는 있어서 부모 인스턴스의 멤버 개수는 자식 인스턴스의 멤버 개수보다 항상 적거나 같다. 즉, 상위 클래스의 참조변수로 자식 클래스의 인스턴스를 생성하는 것만이 허용된다.

#

### 참조변수의 형변환

기본형 변수와 같이 참조변수도 형변환이 가능하다. 단, **서로 상속관계에 있는 클래스사이에서만 가능하기 때문에 자식타입의 참조변수를 부모타입의 참조변수로, 부모타입의 참조변수를 자식타입의 참조변수로의 형변환만 가능하다.**

기본형 변수의 형변환에서 작은 자료형에서 큰 자료형의 형변환이 생략이 가능하듯이, 참조형 변수의 형변환에서는 자식타입의 참조변수를 부모타입으로 형변환하는 경우에는 형변환을 명시하지 않아도 좋다.

> - 자식타입 -> 부모타입 (Up-casting): 형변환 생략가능
> - 부모타입 -> 자식타입 (Down-casting): 형변환 생략가능

**즉, 부모에서 자식은 여럿이 있을 수 있기 때문에 형변환시에는 자식을 명시해야 하나, 자식은 부모가 유일하므로 명시하지 않아도 좋은 것이다.**

참조변수간의 형변환 역시 `캐스트 연산자`를 활용하여, 괄호`()`안에 변환하고자 하는 타입의 이름(클래스명)을 적어주면 된다.

```java
Bird b = new Duck(); // 아래와 같은 의미

Bird b = (Bird)new Duck();

// 즉, Duck d = new Duck();
// Bird b = (Bird)d;
```

상속관계가 아닌, 예를 들어 한 부모를 공유하는 두 자식 클래스를 형제라 볼 수 있지만, 이 관계는 형변환이 불가하다.

> 형변환은 참조변수의 타입을 변환하는 것이지, 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.

```java
class CastingTest {
    public static void main(String args[]) {
        Bird b = new Bird();
        Bird b2 = null;
        Duck d = null

        d = (Duck)b; // 컴파일은 되지만 실행 불가
        b2 = d;
    }
}
```

위 예제는 컴파일은 가능하지만, 실행 시 에러(`ClassCastException`)가 발생한다. 에러가 발생한 곳은 `d = (Duck)b;`이며, 발생 이유는 형변환에 오류가 있기 때문이다. 캐스트 연산자를 이용해서 부모타입의 참조 변수를 자식타입의 참조변수로 형변환한 것이기 때문에 문제가 없어 보이지만, 문제는 참조변수 `b`가 참조하고 있는 인스턴스가 `Bird`타입의 인스턴스라는 점에 있다. **부모타입의 인스턴스를 자식타입의 참조변수로 참조하는 것은 허용되지 않는다.**

따라서 `Bird b = new Bird();`를 `Bird b = new Duck();`와 같이 변경하면, 컴파일할 때 뿐 만 아니라 실행할 때에도 에러가 발생하지 않을 것이다.

컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 알지 못한다. 그래서 컴파일 시에는 문제가 없었지만, 실행시 에러가 발생해 비정상 종료가 된 것이다.

> 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, **참조변수가 가리키는 인스턴스의 자식타입으로 형변환은 허용되지 않는다. 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인해야 한다.**

### instanceof 연산자

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 `instanceof`연산자를 사용한다. 주로 조건문에 사용되며 `instanceof`의 왼쪽에는 참조변수를, 오른쪽에는 타입(클래스명)이 피연산자로 위치한다. 그리고 연산의 결과로 `boolean`값인 `true`와 `false` 중 하나를 반환한다.

> `instanceof`를 이용한 연산결과로 `true`를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 의미한다.

```java
void check(Bird b) {
    if(b instance of Duck) // true
        System.out.println("형변환 가능");
}
```

위의 코드처럼 `Bird` 타입의 참조변수 `b`를 매개변수로 넘겨받을 때, 이 `b`는 `Bird`클래스 또는 그 자식 클래스의 인스턴스를 넘겨받겠지만 메서드 내에서는 정확이 어떤 인스턴스인지 알 수 없다. 그래서 `instanceof`연산자를 이용해서 참조변수 `b`가 가리키고 있는 인스턴스의 타입을 체크하고, 적절히 형변환을 수행해 작업을 이어간다.

부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있기 때문에, 참조변수의 타입과 인스턴스의 타입이 항상 일치하지는 않는다는 것을 배웠다. 부모타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있다.

> 실제 인스턴스와 같은 타입의 `instanceof`연산 이외에 부모타입의 `instanceof`연산에도 true를 결과로 얻으며, `instanceof`연산의 결과가 `true`라는 것은 검사한 타입으로 형변환하여도 아무런 문제가 없다는 것을 의미한다.

### 참조변수와 인스턴스의 연결: 메서드 측면

부모 타입의 참조변수와 자식 타입의 참조변수의 차이점은 사용할 수 있는 멤버의 개수에 국한되지 않는다. 부모 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 부모타입의 참조변수로 자식 인스턴스를 참조하는 경우와 자식타입의 참조변수로 자식 인스턴스를 참조하는 것은 서로 다른 결과를 얻는다.

메서드의 경우 부모 클래스의 메서드를 자식의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출되지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

단, `static`메서드는 `static`변수처럼 참조변수의 타입에 영향을 받는다. 참조변수의 타입에 영향을 받지 않는 것은 인스턴스메서드 뿐이다. 그래서 `static`메서드는 반드시 참조변수가 아닌 `클래스이름.메서드()`로 호출해야 한다.

**결론부터 말하자면, 멤버변수가 부모 클래스와 자식 클래스에 중복으로 정의된 경우, 부모타입의 참조변수를 사용했을 때는 부모 클래스에 선언된 멤버변수가 사용되고, 자식타입의 참조변수를 사용했을 때는 자식 클래스에 선언된 멤버변수가 사용된다.**

하지만 중복 정의되지 않은 경우, 부모타입의 참조변수를 사용했을 때와 자식타입의 참조변수를 사용했을 때의 차이는 없다. 중복된 경우는 참조변수의 타입에 따라 달라지지만, 중복되지 않은 경우 하나뿐이므로 선택의 여지가 없기 때문이다.

```java
class BindingTest{
    public static void main(String[] args) {
        Parent p = new Child();
        Child c = new Child();

        System.out.println("p.x = "+p.x);
        p.method();
        
        System.out.println("c.x = "+c.x);
        c.method();
    }
}

class Parent {
    int x = 100;

    void method()
        System.out.println("Parent Method");
}

class Child extends Parent {
    int x = 200;

    void method()
        System.out.println("Child Method");
}
```

> 실행결과
> p.x = 100
> Child Method
> c.x = 200
> Child Method

타입은 다르지만, 참조변수 `p`와 `c` 모두 `Child`인스턴스를 참조하고 있다. 그리고 `Parent`클래스와 `Child`클래스는 서로 같은 멤버들을 정의하고 있다.

이 때 부모타입만 참조변수 `p`로 `Child`인스턴스의 멤버들을 사용하는 것과 자식타입의 참조변수 `c`로 `Child`인스턴스의 멤버들을 사용하는 것의 차이를 알 수 있다.

메서드인 `method()`의 경우 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입인 `Child`클래스에 정의된 메서드가 호출되지만, 인스턴스변수인 `x`는 참조변수의 타입에 따라서 달라진다.

```java
class BindingTest2 {
    public static void main(String[] args) {
        Parent p = new Child();
        Child c = new Child();

        System.out.println("p.x = "+p.x);
        p.method();
        
        System.out.println("c.x = "+c.x);
        c.method();
    }
}

class Parent {
    int x = 100;

    void method() {
        System.out.println("Parent Method");
    }
}

class Child extends Parent { }
```

이전의 예제와는 달리 `Child`클래스에는 아무런 멤버도 정의되어 있지 않고 단순히 부모로부터 멤버들을 상속받는다. 따라서 참조변수의 타입에 관계없이 부모의 멤버들을 사용하게 된다.

이처럼 자식 클래스에서 부모 클래스의 멤버를 중복으로 정의하지 않았을 때는 참조변수의 타입에 따른 변화는 없다. 어느 클래스의 멤버가 호출되어야 할지, 즉 부모의 멤버가 호출되어야 할 지, 자식의 멤버가 호출되어야 할 지에 대한 선택의 여지가 없기 때문이다. 참조변수의 타입에 따라 결과가 달라지는 경우는 부모 클래스의 멤버변수와 같은 이름의 멤버변수를 자식 클래스에 중복해서 정의한 경우뿐이다.

```java
class BindingTest3 {
    public static void main(String[] args) {
        Parent p = new Child();
        Child c = new Child();

        System.out.println("p.x = "+p.x);
        p.method();
        
        System.out.println("c.x = "+c.x);
        c.method();
    }
}

class Parent {
    int x = 100;

    void method()
        System.out.println("Parent Method");
}

class Child extends Parent {
    int x = 200;

    void method() {
        System.out.println("x="+x);
        System.out.println("super.x="+super.x);
        System.out.println("this.x="+this.x);
    }
}
```

자식 클래스 `Child`에 선언된 인스턴스변수 `x`와 부모 클래스 `Parent`로부터 상속받은 인스턴스변수 `x`를 구분하는데 참조변수 `super`와 `this`가 사용된다. 자식인 `Child`클래스에서의 `super.x`는 부모 클래스인 `Parent`에 선언된 인스턴스변수 `x`를 뜻하며, `this.x` 또는 `x`는 `Child`클래스의 인스턴스변수 `x`를 뜻한다. 따라서 위 결과에서 `x`와 `this.x`의 결과의 값이 같다.

이전에 언급하였듯 멤버변수들은 주로 `private`로 접근을 제한하고, 외부에서는 메서드를 통해서만 멤버변수에 접근할 수 있도록 하지, 이번 예제에서처럼 다른 외부 클래스에서 참조변수를 통해 직접적으로 인스턴스변수에 접근할 수 있게 하지 않는다. **인스턴수변수에 직접 접근하면, 참조변수의 타입에 따라 사용되는 인스턴스변수가 달라질 수 있으므로 주의해야 한다.**

### 매개변수의 다형성

참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다. 아래와 같이 `Bird`, `Duck`, `Goose`, `Chicken`, `Buyer` 클래스가 정의되어 있다.

```java
class Bird {
    int price;      // 가격
    int point;      // 구매하면 주는 포인트
}

class Duck extends Bird {}
class Goose extends Bird {}
class Chicken extends Bird {}

class Buyer {
    int money = 1000;
    int point = 0;
}
```

`Buyer`가 `Duck`, `Goose`, `Chicken`을 산다고 하자. `Buyer`에 물건을 구입하는 기능의 메서드를 추가해본다면 다음과 같다. 구입할 제품을 넘겨받아야 하므로 매개변수를 `Duck`으로 전달받는다.

```java
void buy(Duck d) {
    money -= d.price;
    point += d.point;
}
```

근데 이 메서드로는 `Duck`만을 구입할 수 있다. 따라서 다음과 같이 매개변수에 다형성을 적용하면 하나의 메서드로 처리할 수 있다.

```java
void buy(Bird b) {
    money -= b.price;
    point += b.point;
}
```

매개변수가 `Bird`타입의 참조변수라는 것은, 메서드의 매개변수로 `Bird`클래스의 자식타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 것이다. 그리고 `Bird`클래스에 `price`와 `point`가 선언되어 있기 때문에 참조변수 `b`로 인스턴스의 변수를 사용할 수 있다.

### 객체를 배열로 다루기

부모타입의 참조변수로 자식타입의 객체를 참조하는 것이 가능하므로, `Bird`클래스가 `Duck`, `Goose`, `Chicken`의 부모일 때, 다음과 같이 할 수 있다.

```java
Bird b1 = new Duck();
Bird b2 = new Goose();
Bird b3 = new Chicken();
```

이를 `Bird`타입의 참조변수 배열로 처리하면 아래와 같다.

```java
Bird b[] = new Bird[3];
b[1] = new Duck();
b[2] = new Goose();
b[3] = new Chicken();
```

이처럼 부모타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다. 또는 묶어서 다루고싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다.

`Vector`클래스는 내부적으로 `Object`타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있다. 그리고 배열의 크기를 알아서 관리해주기 때문에 저장할 인스턴스의 개수에 신경쓰지 않아도 된다.

[Vector 클래스](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html)