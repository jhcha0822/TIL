# 접근 제어자

접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근 제어자가 `default`임을 알리기 위해 실제로 `default`를 붙이지는 않는다. `클래스`나 `멤버변수`, `메서드`, `생성자`에 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 `default`임을 뜻한다.

> 접근 제어자가 사용될 수 있는 곳 - `클래스`, `멤버변수`, `메서드`, `생성자`<br>
> `private`: 같은 클래스 내에서만 접근이 가능하다.<br>
> `default`: 같은 패키지 내에서만 접근이 가능하다.<br>
> `protected`: 같은 패키지 내에서, 그리고 다른 패키지의 자식클래스에서 접근이 가능하다.<br>
> `public`: 접근 제한이 전혀 없다.

|제어자|같은 클래스|같은 패키지|자식 클래스|전체|
|:-:|:-:|:-:|:-:|:-:|
|`public`|O|O|O|O|
|`protected`|O|O|O||
|(`default`)|O|O|||
|`private`|O||||

접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 나열한다면 다음과 같다.

> `public` > `protected` > (`default`) > `private`

`public`은 접근 제한이 전혀 없는 것이고, `private`은 같은 클래스 내에서만 사용하도록 제한하는 가장 높은 제한이다. 그리고 `default`는 같은 패키지내의 클래스에서만 접근이 가능하도록 하는 것이다.

마지막으로 `protected`는 패키지에 관계없이 상속관계 있는 자식클래스에서 접근할 수 있도록 하는 것이 제한목적이지만, 같은 패키지 내에서도 접근이 가능하다. 그래서 `protected`가 `default`보다 접근범위가 더 넓다.

#### 대상에 따라 사용할 수 있는 접근 제어자

|대상|사용가능한 접근 제어자|
|:-:|:-:|
|클래스|`public`, (`default`)|
|메서드<br>멤버변수|`public`, `protected`, (`default`), `private`|
|지역변수|없음|

### 접근 제어자를 이용한 캡슐화

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서다.

데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.

이것을 데이터 감추기(`data hiding`)라고 하며, 객체지향개념의 캡슐화(`encapsulation`)에 해당하는 내용이다.

또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서다.

외부에서 접근할 필요가 없는 멤버들은 `private`으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다. 이 또한 캡슐화이다.

> 접근 제어자를 사용하는 이유
> - 외부로부터 데이터를 보호하기 위해서
> - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

만일 메서드 하나를 변경해야 한다고 가정했을 때, 이 메서드의 접근 제어자가 `public`이라면, 메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다. 그러나 접근 제어자가 `default`라면 패키지 내부만 확인해 보면 되고, `private`이면 클래스 하나만 살펴보면 된다. 이처럼 접근 제어자 하나가 상당한 차이를 만들어낼 수 있기에 범위를 최소화하는 것이 중요하다.

```java
public class Time {
    private int hour;    // 접근 제어자를 private로 하여
    private int minute;  // 외부에서 직접 접근하지 못하도록 한다
    private int second;

    public int getHour() {
        return hour;
    }
    public void setHour(int hour) {
        if(hour<0 || hour>23)
            return;
        this.hour = hour;
    }
    public int getMinute() {
        if(minute<0 || minute>59)
            return;
        this.minute = minute;
    }
    public int getSecond() {
        return second;
    }
    public void setSecond(int second) {
        if(second<0 || second>59)
            return;
        this.second = second;
    }
}
```
`get`으로 시작하는 메서드는 단순히 멤버변수의 값을 반환하는 일을 하고, `set`으로 시작하는 메서드는 매개변수에 지정된 값을 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성되어 있다.

만일 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자식클래스에서 접근하는 것이 가능하도록 하기 위해 `private`대신 `protected`를 사용한다. `private`이 붙은 멤버는 자손 클래스에서도 접근이 불가능하기 때문이다.

보통 멤버변수의 값을 읽는 메서드의 이름을 `get멤버변수이름`으로 하고, 멤버변수의 값을 변경하는 메서드의 이름을 `set멤버변수이름`으로 한다. 또한 `get`으로 시작하는 메서드를 `getter`, `set`으로 시작하는 메서드를 `setter`라 한다.

### 생성자의 접근 제어자

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.

생성자의 접근 제어자를 `private`로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다. 그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```java
class Singleton {
    private Singleton() {
        ...
    }
    ...
}
```

대신 인스턴스를 생성해서 반환해주는 `public`메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다. 이 메서드는 `public`인 동시에 `static`이어야 한다.

```java
class Singleton {
    ...
    private static Singleton s = new Singleton(); // getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야 한다
    private Singleton() {
        ...
    }
    // 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 한다
    public static Singleton getInstance() {
        return s;
    }
    ...
}
```

이렇게 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 `public`메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.

또, 생성자가 `private`인 클래스는 다른 클래스의 부모가 될 수 없다. 왜냐하면, 자식클래스의 인스턴스를 생성할 때 부모클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 `private`이므로 자식클래스에서 호출하는 것이 불가능하기 때문이다. 그래서 클래스 앞에 `final`을 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.

`Math`클래스는 몇 개의 상수와 `static`메서드만으로 구성되어 있기 때문에 인스턴스를 생성할 필요가 없다. 그래서 외부로부터의 불필요한 접근을 막기 위해 생성자의 접근 제어자를 `private`로 지정하였다.

```java
public final class Math {
    private Math();
}
```

### 제어자(modifier)의 조합

`static`, `final`, `abstract` 외에도 제어자들이 존재한다. 

제어자가 사용될 수 있는 대상을 중심으로 제어자를 정리한다면 다음과 같다.

|대상|사용가능한 제어자|
|:-:|:-:|
|클래스|`public`, (`default`), `final`, `abstract`|
|메서드|모든 접근 제어자, `final`, `abstract`, `static`|
|멤버변수|모든 접근 제어자, `final`, `static`|
|지역변수|`final`|

제어자를 사용할 때 주의해야 할 사항은 다음과 같다.

> 1. 메서드에 `static`과 `abstract`를 함께 사용할 수 없다.
>> - `statiic`메서드는 몸통이 있는 메서드에만 사용할 수 있다.
> 2. 클래스에 `abstract`와 `final`을 동시에 사용할 수 없다.
>> - 클래스에 사용되는 `final`은 클래스를 확장할 수 없다는 의미이고, `static`은 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
> 3. `abstract`메서드의 접근 제어자가 `private`일 수 없다.
>> - `abstract`클래스는 자식클래스에서 구현해주어야 하는데, 접근 제어자가 `private`이면 자식클래스에서 접근이 불가하기 때문이다.
> 4. 메서드에 `private`와 `final`을 같이 사용할 필요는 없다.
>> - 접근 제어자가 `private`인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용하여도 의미가 충분하다.