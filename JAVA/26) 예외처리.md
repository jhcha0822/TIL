# 예외처리(exception handling)

프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 `프로그램 에러` 또는 `오류`라고 한다.

이를 발생시점에 따라 다음과 같이 나눌 수 있다.

> `컴파일 에러`: 컴파일 시에 발생하는 에러<br>
> `런타임 에러`: 실행 시에 발생하는 에러<br>
> `논리적 에러`: 실행은 되지만, 의도와 다르게 동작하는 것

소스 파일을 컴파일하면 컴파일러가 소스코드(`*.java`)에 대해 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행하여 오류가 있는지를 알려준다. 컴파일러가 알려준 에러들을 모두 수정해서 컴파일을 성공적으로 마치고 나면, 클래스파일이 생성되고, 생성된 클래스파일을 실행할 수 있는 것이다.

하지만 컴파일을 에러없이 성공적으로 마쳤다 하여 프로그램의 실행 시에도 에러가 발생하지 않는 것은 아니다. 컴파일러가 소스코드의 기본적인 사항은 컴파일 시에 모두 걸러 줄 수는 있지만, 실행도중에 발생할 수 있는 잠재적인 오류까지 검사할 수 없기 때문에 컴파일이 잘 되었어도 실행 중에 에러에 의해 잘못된 결과를 얻거나 프로그램이 비정상적으로 종료될 수 있다. 이를 `런타임 에러`라 하며, 프로그램이 실행 중 동작을 멈춘 상태로 오래 지속되거나, 갑자기 프로그램이 멈추고 종료되는 등이 이에 해당한다.

런타임 에러를 방지하기 위해서는 프로그램의 실행도중 발생할 수 있는 모든 경우의 수를 고려하여 이에 대한 대비를 하는 것이 필요하다. 자바에서는 실행 시(`runtime`) 발생할 수 있는 프로그램 오류를 에러(`error`)와 예외(`exception`)으로 구분한다.

에러는 메모리 부족(`OutOfMemoryError`)이나 스택오버플로우(`StackOverFlowError`)와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습이 가능한 비교적 덜 심각한 부류이다.

에러가 발생하면, 프로그램의 비정상적인 종료를 막을 수 없지만 예외는 발생하더라도 프로그래머가 적절한 코드를 미리 작성해 놓는 것으로 방지가 가능하다.

### 예외 클래스의 계층구조


### 예외처리: try-catch문

프로그램의 실행 도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다.

예외처리(exception handling)이란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종효를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다.

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외(uncaught exception)은 JVM의 예외처리기(`UncaughtExceptionHandler`)가 받아서 예외의 원인을 화면에 출력한다.

예외를 처리하기 위해서는 try-catch문을 사용한다

```java
try {
    // 예외가 발생할 가능성이 있는 문장
} catch(Exception1 e1) {
    // 예외(Exception1)가 발생했을 경우, 이를 처리하기 위한 문장
} catch(Exception2 e2) {
    // 예외(Exception2)가 발생했을 경우, 이를 처리하기 위한 문장
}
```
하나의 `try`블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 `catch`블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한개의 `catch`블럭만 수행된다. 발생한 예의의 종류와 일치하는 `catch`블럭이 없으면 예외는 처리되지 않는다.

```java
class ExceptionEx1 {
    public static void main(String[] args) {
        try {
            try {
                //
            } catch(Exception e) {
                try {
                    //
                }  catch(Exception e) {
                    try {
                        //
                    } catch(Exception e) { // 에러, e의 중복사용
                        //
                    }
                }
            }
        }
    }
}

하나의 메서드 내에 여러개의 `try-catch`문이 사용될 수 있으며, `try`블럭 또는 `catch`블럭 내에 또 다른 `try-catch`문이 포함될 수 있다.(`catch`블럭 내의 코드에서도 예외가 발생 가능) `catch`블럭의 괄호 내에 선언된 변수는 `catch`블럭 내에서만 유효하기 때문에, 위의 모든 `catch`블럭에 참조변수 `e`하나 만을 사용해도 된다.

그러나 `catch`블럭 내에 또 하나의 `try-catch`문이 포함된 경우, 같은 이름의 참조변수를 사용해서는 안된다. 각 `catch`블럭에 선언된 두 참조변수의 영역이 서로 겹치므로 다른 이름을 사용해야만 서로 구분되기 때문이다.
```

### `try-catch`문에서의 흐름

`try-catch`문에서, 예외가 발생한 경우와 발생하지 않았을 때의 흐름(문장의 실행순서)이 달라지는데, 다음과 같다.

> `try`블럭 내에서 예외가 발생한 경우
> 1. 발생한 예외와 일치하는 `catch`블럭이 있는지 확인
> 2. 일치하는 `catch`블럭을 찾게 되면, 그 `catch`블럭 내의 문장들을 수행하고, 전체 `try-catch`문을 빠져나가서 그 다음 문장을 수행한다. 만일 일치하는 `catch`블럭을 찾지 못하면, 예외는 처리되지 않는다.

> `try` 블럭 내에서 예외가 발생하지 않은 경우
> 1. `catch`블럭을 거치지 않고 전체 `try-catch`문을 빠져나가서 수행을 계속한다.

### 
